function fits = fitCandidateSpots(handleIAI, groupInfo, brightSpotsIntensities, fishAnalysisData)
%fitCandidateSpots Perform a gaussian fit of the brightest spots in each of the columns
%
% %%% Algorithm %%%
%
% For each of the detected columns: identify the brightest spot. Use a "bright spot map"
% to find neighboring bright spots and their intensities. (Neighboring = within
% fit_extNeighborhood pixels). Of these, keep only those with large enough DoG
% intensities compared to the main point that we are trying to fit (use
% fit_maxIntensityRatio) -- the idea is that dim spots can be safely neglected, while
% spots with intensities comparable to the main spot intensity could spoil the gaussian
% fit unless we fit with multiple gaussians.
%
% Cut out a square plaquette of size fit_neighborhood x fit_neighborhood pixels from the
% image (at z containing the main spot) and fit it with a constant offset + a simple
% Gaussian or multiple Gaussians. The main Gaussian fit is elliptical, so has the
% following parameters: 
% c_x, c_y  (the center)
% r_x, r_y  (the two radii)
% theta     (incline angle)
% amp       (amplitude)
%
% The idea behind making an elliptical fit is to introduce additional selection
% criteria: if the spot is not circular enough, it means that either this is not
% actually a spot or there is some noise nearby spoiling the fit and in any case we
% should discard the point.
%
% The other spots are being fitted simply so as not to spoil the main fit, so a simple
% circular Gaussian of a standard size is good enough for those (the only parameters are
% amplitude and location per spot). 
%
% Repeat the above for all columns.
%
% 
% %%% Saved information %%%
% 
% For each fit, save:
%   Gaussian fit parameters of the main spot:
%       offset
%       x, y of center
%       theta
%       r_x, r_y (the two standard deviations of an elliptical gaussian)
%       amplitude
%   Least-squares deviation of the fit from the original image
%   x,y,z coordinates of the originally identified bright spot's center 
%   shadows: list of DoG spot intensities in the column of which the fitted spot was the
%       brightest; in order of z (So DoG intensity of the fitted spot is max(shadows))
%   extraSpotsFitParams = vector of fit parameters found for the extra spots (may be
%       empty if no sufficiently bright spots were detected nearby). The length of this
%       vector tells us how many neighboring spots were fit at the same time as the main
%       one: numberOfNeighbors = length(extraSpotsFitParams) / 3.
%
% If storeSnippets is set to "true", for ech fit, store the snippet of the original
% image (field .snippet) that was being fit (called "plaquette" in the code). There is
% no need to store the image generated by those parameters, because we can regenerate
% it quickly using generateFit.
%
% If storeSnippets is set to false, the information that would have been stored in
% .snippet can be recovered from the original images, but that would involve once
% again loading the images, aligning them and renormalizaing them. Therefore, it is a
% good idea to keep storeSnippets=true whenever we can afford it. The memory consumption
% is (2*extNeighborhood+1)^2 x sizeof(uint16) x number of fits, i.e. typically
% (for extNeighborhood=6) an additional 1 megabyte for 3000 fits, which seems quite
% affordable. 
%
% Why store the snippets at all? Once we perform the elliptical gaussian fitting, we
% will use the results to choose "good" spots (those that are round enough and are
% within certain size limits). We will then re-fit them, this time using a circular
% gaussian instead of an elliptical one. To this end, it is very convenient to have the
% snippets already extracted and the optimal fit parameters of extra spots stored in
% fishAnalysisData. That way we can start a new fit from a point which should be very
% close to optimal in most of the parameters.
%
%
%   Part of FishToolbox v2.0
%   Original code by Gasper Tkacik (FishToolbox v1.0)
%   Rewritten with modifications by Mikhail Tikhonov
%   August 2010
%

% TODO: is it true that for multi fit we must fit a greater area?

fout=fishAnalysisData.params.outputFileID;
fprintf(fout,'fitCandidateSpots:\n');
numtype=fishAnalysisData.params.dataType;

sizeY = fishAnalysisData.stackSize(1);
sizeX = fishAnalysisData.stackSize(2);
sizeZ = fishAnalysisData.stackSize(3);

brightestZ=groupInfo.brightestZ;
brightSpotsFrameDistribution=groupInfo.brightSpotsFrameDistribution;
candidateSpots=groupInfo.candidateSpots;
brightSpotsLocations=groupInfo.brightSpotsLocations;

extNeighb=fishAnalysisData.params.fit_extNeighborhood;

performFits = ~(fishAnalysisData.params.fit_prefitMode==FITMODE_NONE);

% Preallocate memory for the fits structure array.
% Create an empty fitParams structure; specify types explicitly to use less memory.
% TODO: how do you preallocate memory for fields of variable length?
if performFits
    fparamsTemplate=struct('off',single(0),...
               'x_fit',single(0),...
               'y_fit',single(0),...
               'theta',single(0),...
               'r_x',single(fishAnalysisData.params.fit_standardSize),...
               'r_y',single(fishAnalysisData.params.fit_standardSize),...
               'amp',single(0),...
               'lsq',single(-1),... % if no fitting was performed, lsq will stay -1
               'x',uint16(0),...
               'y',uint16(0),...
               'z',uint16(0),...
               'shadowsDog',zeros(5,1,'single'),... % DoG intens. of the entire column
               'shadowsRaw',zeros(5,1,'single'),... % Raw intens. of the entire column
               'extraSpotsFitParams',[],...
               'info',uint16(0),...
               'snippet',zeros(2*extNeighb+1,numtype));
else
    fparamsTemplate=struct(...
               'x',uint16(0),...
               'y',uint16(0),...
               'z',uint16(0),...
               'shadowsDog',zeros(5,1,'single'),... % DoG intens. of the entire column
               'shadowsRaw',zeros(5,1,'single'),... % Raw intens. of the entire column
               'snippet',zeros(2*extNeighb+1,numtype));
end
               
if ~fishAnalysisData.params.fit_storeSnippets
    % Do not store snippets of the original image
    fparamsTemplate=rmfield(fparamsTemplate,'snippet');
end

fits(length(candidateSpots))=fparamsTemplate;
fprintf(fout,'\tStarted the fitting cycle.\n');

processedFits=0;
totalFits=length(candidateSpots);

if fishAnalysisData.params.fit_store3dSnippetSize>0;
    channelGroupPrefix = sprintf('%d',groupInfo.ch);
    snipSize3d=2*fishAnalysisData.params.fit_store3dSnippetSize+1;
    fname = fullfile(fishAnalysisData.stackDescription.adjustments,...
            ['BRIGHT_SPOT_SNIPPETS_', channelGroupPrefix]);
    fname3d = fullfile(fishAnalysisData.stackDescription.adjustments,...
            ['3d_snippets_', channelGroupPrefix]);
    fprintf(fout,'\tLoading the preliminary list of bright spot snippets...\n');
    brightSpotSnippets = load(fname);
    brightSpotSnippets = brightSpotSnippets.brightSpotSnippets;
    snippets3d = zeros([totalFits, fishAnalysisData.params.shadowN, snipSize3d, snipSize3d],'uint16');
    brightestN3d = zeros([totalFits, 1]);
end


% As usual, we will need a bright spots map when we search for neighbors, but we care
% about memory usage, so instead of creating it as a whole, we'll have to be going frame
% by frame. So we'll have to scan through the candidate spots several times, each time
% fitting only those that fall onto the layer we are currently considering, because only
% for these points we can find their bright neighbors, and that is important for fits.

% We will be filling the fits array in order as we go over spots a given frame; for a
% given index in the fits array, what is the index of the spot that is actually being
% fir? 
[ignore, fitNumberToCandidateNumber] = sort(brightestZ);
% The first point in the new fits array is the one that was at index
% FitNumberToCandidateNumber(1) in the candidateSpots array, etc. 
if fishAnalysisData.params.useGUIprogressbar
    progressbar(0);
end

if strcmpi(fishAnalysisData.params.fit_noiseModel,'fixed_std_gaussian')
    varNoiseStd=false;
elseif strcmpi(fishAnalysisData.params.fit_noiseModel,'var_std_gaussian')
    varNoiseStd=true;
else
    error('FishToolbox:fitSpots:noiseModel',['Unrecognized noise model %s. ',...
        'Must be ''fixed_std_gaussian'' or ''var_std_gaussian''']);
end
minSpotsToJustifyParallelizing=...
    fishAnalysisData.params.fit_minSpotsToJustifyParallelizing;

params = fishAnalysisData.params;

% Do not fit points in the first or last frame of the stack; their intensity means
% nothing... 
if fishAnalysisData.params.processColumnsPeakingAtStackEdge
    frameRange = 1:sizeZ;
else
    frameRange = 2:sizeZ-1;
end
for frame=frameRange
    candidateSpotsNumberOnFrame = sum(brightestZ==frame);
    if candidateSpotsNumberOnFrame==0
        continue; % No candidate spots on this frame
    end
    
    % Create a frame of the map of bright spots to be able to search for neighbors
    % quickly. See comments in chooseCandidateSpots for a description of what a "spot
    % map" is. 
    brightSpotMapFrame = zeros([sizeY,sizeX],'uint32');
    brightSpotsOnFrame=...
        brightSpotsFrameDistribution(frame):brightSpotsFrameDistribution(frame+1)-1;
    
    if fishAnalysisData.params.saveMemory
        brightSpotMapFrame = setMultiplePixelsSlow(brightSpotMapFrame, ...
            brightSpotsOnFrame,...
            brightSpotsLocations(:,1), ...
            brightSpotsLocations(:,2), ...
            brightSpotsOnFrame);
    else
        brightSpotMapFrame = setMultiplePixelsSlow(brightSpotMapFrame, ...
            brightSpotsLocations(brightSpotsOnFrame,1), ...
            brightSpotsLocations(brightSpotsOnFrame,2), ...
            brightSpotsOnFrame);
    end
    % Load the signal stack frame in question
    img = getImageFrame(handleIAI, frame);
    offsetEstimate=double(mean(mean(img,2),1));
    
    % Go over all spots whose brightest shadow lies on the layer currently under
    % consideration. Use a parralel-for loop for speed. (Fitting is the most
    % time-consuming step of the analysis, so it is natural to use as much computing
    % resources as we can at this stage.)
    if candidateSpotsNumberOnFrame<minSpotsToJustifyParallelizing ...
            || (params.fit_prefitMode==FITMODE_FAKE) || (params.fit_prefitMode==FITMODE_NONE)
        M=0;
    else
        M=fishAnalysisData.params.matlabWorkersToUse;
    end
    
    if fishAnalysisData.params.fit_store3dSnippetSize>0
        for i=processedFits+1:processedFits+candidateSpotsNumberOnFrame
            [snippets3d(i,:,:,:) brightestN3d(i)] = get3dsnippet(fitNumberToCandidateNumber(i));
        end
    end

    
%    for i=processedFits+1:processedFits+candidateSpotsNumberOnFrame
    parfor (i=processedFits+1:processedFits+candidateSpotsNumberOnFrame, M)
    %for i=processedFits+1:processedFits+candidateSpotsNumberOnFrame
        % The main argument is the first one. The other arguments provide read-only
        % acess to the variables of the calling function
        fits(i)=fitSpot(fitNumberToCandidateNumber(i),...
                    groupInfo, brightSpotsIntensities, img, offsetEstimate, ...
                    frame, brightSpotMapFrame, varNoiseStd, params, fparamsTemplate);
    end
        
    processedFits = processedFits+candidateSpotsNumberOnFrame;
        
    %%% User interface %%%
    fprintf(fout,'\tProcessed %d fits out of %d...\n',processedFits,totalFits);
    if fishAnalysisData.params.useGUIprogressbar
        stopBar=progressbar(processedFits/totalFits);
        if stopBar, break; end;
    end
    %%% End (user interface) %%%    
end

if fishAnalysisData.params.fit_store3dSnippetSize>0
    fprintf(fout,'\tSaving the list of 3d snippets.\n');
    delete([fname,'.mat']);
    save(fname3d, 'snippets3d', 'brightestN3d','-v7.3');
end


    function [snip3d brightestN3d] = get3dsnippet(i)
        % indices of spots constituting the column of shadows
        cands = groupInfo.candidateSpots{i};
        % these are all the shadows. But we only need to pick shadowN consecutive slices 
        % with the brightest slice as close to the middle as possible
        % assign scores to possible starting points depending on how close the middle
        % would be to the brightest frame
        brightestN = double(groupInfo.brightestN(i));
        scores = abs((1:length(cands))+(fishAnalysisData.params.shadowN+1)/2-1-brightestN);
        scores(end-fishAnalysisData.params.shadowN+2:end)=Inf;
        [ignore bestStart] = min(scores);
        if isinf(ignore)
            error('There''s a problem!');
        end
        cands = cands(bestStart:bestStart+fishAnalysisData.params.shadowN-1);
        maxIntSpot = cands(brightestN-bestStart+1);
        brightestN3d = brightestN-bestStart+1;
        
        % ok so now cands contains the indices of spots that should be included in the
        % 3d snippet. The snippet should be centered around the location of the
        % brightest spot.
        x0=brightSpotsLocations(maxIntSpot,1);
        y0=brightSpotsLocations(maxIntSpot,2);
        extSnipSize = snipSize3d+2*fishAnalysisData.params.shadow_dist; % includes the temporary safety margin
        snip3d = zeros([fishAnalysisData.params.shadowN extSnipSize extSnipSize]);
        % align them vertically to take into account that they are all centered at the
        % locations of their respective spots, not at the same xy locations in the stack
        for fr=1:fishAnalysisData.params.shadowN
            x1=brightSpotsLocations(cands(fr),1);
            y1=brightSpotsLocations(cands(fr),2);
            snip3d(fr,:,:)=circshift(brightSpotSnippets(cands(fr),:,:),double([y1-y0,x1-x0]));
        end
        % take the column centered around the location of the spot on the brightest
        % slice
        selectRange = (fishAnalysisData.params.shadow_dist+1):...
                       (snipSize3d+fishAnalysisData.params.shadow_dist);
        snip3d = snip3d(:,selectRange,selectRange);
    end
end

% The main argument is the first one. The other arguments provide read-only
% acess to the variables of the calling function
function fitParams=fitSpot(i, groupInfo, spotInt, img, offsetEstimate, ...
                             frame, brightSpotMapFrame, varNoiseStd, params, fparamsTemplate)
    
    brightestN=groupInfo.brightestN;
    candidateSpots = groupInfo.candidateSpots;
    brightSpotsLocations = groupInfo.brightSpotsLocations;

    neighb=params.fit_neighborhood;
    extNeighb=params.fit_extNeighborhood;
    maxIntRatio=params.fit_maxIntRatio;
                            
    % This is a function that fits one spot. 
    spotsInColumn = candidateSpots{i};
    maxIntSpot = spotsInColumn(brightestN(i));
    % maxIntSpot is the index of the column's brightest spot in the brightSpots list

    x0=brightSpotsLocations(maxIntSpot,1);
    y0=brightSpotsLocations(maxIntSpot,2);

    if params.fit_prefitMode == FITMODE_NONE
        % do not perform the fitting and be honest about it :)
        fitParams = fparamsTemplate;
        if params.fit_storeSnippets
            L=neighb;
            % plaquette is of the same numeric class (single or uint16) as imageStack
            plaquette=img(y0-L:y0+L, x0-L:x0+L);
            fitParams.snippet=plaquette;
        end
    elseif params.fit_prefitMode == FITMODE_FAKE
        % let's do our best to approximate the result without actually
        % performing any fitting (jsut put in what we already know: the
        % spots is aroughly at this location)
        fitParams = fparamsTemplate;
        L=neighb;
        % plaquette is of the same numeric class (single or uint16) as imageStack
        plaquette=img(y0-L:y0+L, x0-L:x0+L);
        if params.fit_storeSnippets
            fitParams.snippet=plaquette;
        end        
        fitParams.off = mean(plaquette(:)); % mean is faster than median
        fitParams.x_fit = single(x0);
        fitParams.y_fit = single(y0);
        fitParams.amp = single(plaquette(L+1,L+1))*...
            single(2*pi*single(params.fit_standardSize^2));
    else
        % do the fitting
        
        % Find indices of the bright spots that are close by in the XY plane
        neighbors=findXYNeighbors(x0, y0, extNeighb, brightSpotMapFrame);
        % Keep only those whose intensities are large enough
        important=spotInt(neighbors)>spotInt(maxIntSpot)/maxIntRatio;
        neighborsToFit=neighbors(important);

        if isempty(neighborsToFit)
            % Fit a smaller plaquette with a simple gaussian
            L=neighb;
            plaquette=img(y0-L:y0+L, x0-L:x0+L);
            extraSpotsInfo=[];
        else
            % Fit a larger plaquette with multiple gaussians
            L=extNeighb;
            plaquette=img(y0-L : y0+L, x0-L : x0+L);
            extraSpotsInfo=brightSpotsLocations(neighborsToFit,1:3);
            extraSpotsInfo(:,1)=extraSpotsInfo(:,1)-x0;
            extraSpotsInfo(:,2)=extraSpotsInfo(:,2)-y0;
            extraSpotsInfo(:,3)=...
                diag(plaquette(extraSpotsInfo(:,2)+L+1,extraSpotsInfo(:,1)+L+1));
        end
        
        if params.fit_prefitMode == FITMODE_CIRCULAR
            fitParams=multiGaussianFit_Circle(double(plaquette),offsetEstimate,...
                double(extraSpotsInfo), varNoiseStd, params);
        elseif params.fit_prefitMode == FITMODE_CIRCULAR_STANDARDSIZE        
            fitParams=multiGaussianFit_StandardCircle(double(plaquette),offsetEstimate,...
                double(extraSpotsInfo), varNoiseStd, params);
        else % params.fit_prefitMode == default (FITMODE_ELLIPTICAL)
            fitParams=multiGaussianFit_Ellipse(double(plaquette),offsetEstimate,...
                double(extraSpotsInfo), varNoiseStd, params);
        end;

        if params.fit_storeSnippets
            % plaquette is of the same numeric class (single or uint16) as imageStack
            fitParams.snippet=plaquette;
        end
        fitParams.x_fit=fitParams.x_fit+single(x0);
        fitParams.y_fit=fitParams.y_fit+single(y0);
    end
    
    fitParams.x=x0;
    fitParams.y=y0;
    fitParams.z=frame;
    fitParams.shadowsDog=spotInt(spotsInColumn,1)';
    fitParams.shadowsRaw=spotInt(spotsInColumn,2)';
end


function fparams = fakeFitParams(params)
fparams=struct('off',-1,...
               'x_fit',-1,...
               'y_fit',-1,...
               'theta',-1,...
               'r_x',-1,...
               'r_y',-1,...
               'amp',-1,...
               'lsq',-1,...
               'x',uint16(0),...
               'y',uint16(0),...
               'z',uint16(0),...
               'shadowsDog',zeros(5,1,params.dataType),...
               'shadowsRaw',zeros(5,1,params.dataType),...
               'extraSpotsFitParams',[],...
               'info',65535);
if params.fit_storeSnippets
    fparams.snippet=[];
end           
end


function neighbors=findXYNeighbors(x0,y0,dist, brightSpotMap)
    localMap=brightSpotMap(y0-dist:y0+dist, x0-dist:x0+dist);
    % If the center of the neighborhood is occupied by a spot itself, this is the spots
    % whose neighbors we are looking for and which should NOT be included in the list of
    % neighbors
    localMap(dist+1,dist+1)=0;
    neighbors=unique(localMap(:));
    % Exclude 0 (which is the first element, because unique returns a sorted output)
    if ~neighbors(1)
        neighbors=neighbors(2:end);
    end
end

function fparams=multiGaussianFit_Ellipse(plaquette, offset0, extraSpotsInfo,...
    varNoiseStd, params)
% Use non-linear least-square optimization
% We would like to minimize 
%   sum over pixels (original image - fit of the image)^2
% Therefore, we must pass to lsqnonlin the vector of pixel values differences.
% plaquette is the image we should fit to our multi-gaussian model. The "plaquette
%   coordinates are centered at (0,0); this is roughly where we assume the main point to
%   be. 
% offset0 is the initial estimate of the constant offset
% extraSpotsInfo is the K-by-3 matrix containing x and y coordinates of the neighboring
%   bright spots (in the plaquette coordinates) and their intensities on the raw image
%   (they are supplied to allow for the future possibility that the center of some of
%   the extra spots might actually be *outside* of the plaquette. This possibility is
%   not currently implemented). 

% The parameters for the fits have to form a vector. So although the different elements
% of this vector have completely different meanings, we'll have to lump them all
% together and parse it into spearate meaningful values when necessary (see generateFit
% below). So, we will be using a vector "parameters" that should be interpreted as the
% values of the fields of the following two structures all written out in a sequence:
%   1) the value of the offset
%   2) mainSpot structure describing the main spot (elliptical Gaussian), with fields
%       cx
%       cy          center coordinates
%       amp         the amplitude
%       theta       incline angle
%       sigmaX
%       sigmaY      the two std parameters
%   3) xtSpots structure array describing the extra spots (Gaussians), with fields
%       cx
%       cy
%       amp
%       % sigma  - NOT VARIED. USING CONSTANT SIZE DEFINED IN "PARAMS".
%
% In other words, the parameters vector for a multigaussian fit with two extra spots is:
% params = [offset, mainSpot.cx, .cy, .amp, .theta, .sigmaX, .sigmaY, extraSpot(1).cx,
%       .cy, .amp, extraSpot(2).cx, .cy, .amp]

standardSize=params.fit_standardSize;
L=(size(plaquette,1)-1)/2;

% The initial values of parameters:
%   The initial offset estimate is suuplied as input to multiGaussianFit
%   The main spot is centered at zero (the plaquette goes from -L to +L), has a standard
%       size, is not inclined and the amplitude is given by the center pixel - offset. 
%   The extra spots have initial locations provided as input to multiGaussianFit, all
%       have standard sizes and the amplitudes are given by pixel values at center
%       locations minus the offset.

if isempty(extraSpotsInfo)
    paramsExtra=[];
    lowerBoundsExtra=[];
    upperBoundsExtra=[];
else    
    paramsExtra=zeros(1,3*size(extraSpotsInfo,1));
    paramsExtra(1:3:end)= extraSpotsInfo(:,1); % x coordinates of centers
    paramsExtra(2:3:end)= extraSpotsInfo(:,2); % y coordinates of centers
    % Amplitudes
    paramsExtra(3:3:end)= 2*pi*standardSize^2*(extraSpotsInfo(:,3)-offset0); 
    
    % Now, set the bounds for the parameters. The extra spots should not be moved around
    % too much (+-2 pixels seems more than reasonable), the other bounds are not really
    % bounding but are simply to ensure no disasters happen.
    
    maxShift = params.fit_extraSpotShift;
    
    lowerBoundsExtra=zeros(1,3*size(extraSpotsInfo,1));
    lowerBoundsExtra(1:3:end)= extraSpotsInfo(:,1)-maxShift; % x coordinates of centers
    lowerBoundsExtra(2:3:end)= extraSpotsInfo(:,2)-maxShift; % y coordinates of centers
    % Amplitudes
    lowerBoundsExtra(3:3:end)= 0; 

    upperBoundsExtra=zeros(1,3*size(extraSpotsInfo,1));
    upperBoundsExtra(1:3:end)= extraSpotsInfo(:,1)+maxShift; % x coordinates of centers
    upperBoundsExtra(2:3:end)= extraSpotsInfo(:,2)+maxShift; % y coordinates of centers
    % Amplitudes
    upperBoundsExtra(3:3:end)= inf; 
end

cShift = params.fit_mainSpotShift;

params0 = [offset0, ...                                         % offset
    0, 0, 2*pi*standardSize^2*(plaquette(L+1,L+1)-offset0), ... % cx, cy, amp
    0, standardSize, standardSize, ...                          % theta, r_x, r_y
    paramsExtra];                                               % extra spots
lowerBounds=[0, ...
    -cShift, -cShift, 0, ...
    -inf, 0, 0, ...
    lowerBoundsExtra];
upperBounds=[inf, ...
    cShift, cShift, inf, ...
    inf, L, L, ...
    upperBoundsExtra];

lsqOptions=optimset('Display','none',...
    'maxfunevals',params.fit_maxfunevals,...
    'maxiter',params.fit_maxiter);

originalPixelVec=plaquette(:)';

[optparams, resid]=...
    lsqnonlin( @vecToMinimize, ...
        params0, lowerBounds, upperBounds, lsqOptions);

% If the fitting procedure set some parameters to the bounding values, that makes the
% fit suspicious. Store this information in infoFlag:
% bit 1: center X or center Y
% bit 2: r_x or r_y
% bit 3: some other parameter

% susp = short for "suspicious"
susp = (optparams == lowerBounds) | (optparams == upperBounds);
infoFlag = 1*uint16(susp(2)|susp(3))+...
           2*uint16(susp(6)|susp(7))+...
           4*uint16(sum(susp([1,4,5,8:end]))>0);
    
fparams=struct('off',single(optparams(1)),...
               'x_fit',single(optparams(2)),...
               'y_fit',single(optparams(3)),...
               'theta',single(optparams(5)),...
               'r_x',single(optparams(6)),...
               'r_y',single(optparams(7)),...
               'amp',single(optparams(4)),...
               'lsq',single(resid),...
               'x',uint16(0),...
               'y',uint16(0),...
               'z',uint16(0),...
               'shadowsDog',zeros(5,1,params.dataType),...
               'shadowsRaw',zeros(5,1,params.dataType),...
               'extraSpotsFitParams',single(optparams(8:end)),...
               'info',infoFlag);

    % Nested function - vector to minimize
           
    % Model the noise either
    %   * as gaussian with a fixed std. In this case the
    %   function to minimize is the sum of squares of deviations.
    %   So return the vector of deviations; 
    % OR
    %   * as gaussian with variance proportional to the mean. (This is a
    %   better approximation to Poisson noise). 
    %   In this case the function to minimize is the sum of squares of [deviations
    %   over standard deviations]. But we are still using lsqnonlin which
    %   minimizes the sum of squares of the components. So return the vector of
    %   deviations divided by standard deviation, i.e. square root of mean at this
    %   given location. 
    function vec = vecToMinimize(parameters)
        % The pixel vector generated using parameters (i.e. the fit to compare to
        % the original) 
        fitPixelVec = generateFit(L,standardSize,parameters(1),...
            parameters(2:7),parameters(8:end));
        if varNoiseStd
            vec = (originalPixelVec-fitPixelVec)./(fitPixelVec.^0.5);
        else
            vec =  originalPixelVec-fitPixelVec;
        end
    end
           
           
end


function fparams=multiGaussianFit_Circle(plaquette, offset0, extraSpotsInfo,...
    varNoiseStd, params)
% Use non-linear least-square optimization
% We would like to minimize 
%   sum over pixels (original image - fit of the image)^2
% Therefore, we must pass to lsqnonlin the vector of pixel values differences.
% plaquette is the image we should fit to our multi-gaussian model. The "plaquette
%   coordinates are centered at (0,0); this is roughly where we assume the main point to
%   be. 
% offset0 is the initial estimate of the constant offset
% extraSpotsInfo is the K-by-3 matrix containing x and y coordinates of the neighboring
%   bright spots (in the plaquette coordinates) and their intensities on the raw image
%   (they are supplied to allow for the future possibility that the center of some of
%   the extra spots might actually be *outside* of the plaquette. This possibility is
%   not currently implemented). 

% The parameters for the fits have to form a vector. So although the different elements
% of this vector have completely different meanings, we'll have to lump them all
% together and parse it into separate meaningful values when necessary (see generateFit). 
% So, we will be using a vector "parameters" that should be interpreted as the
% values of the fields of the following two structures all written out in a sequence:
%   1) the value of the offset
%   2) mainSpot structure describing the main spot (circular Gaussian), with fields
%       cx
%       cy          center coordinates
%       amp         the amplitude
%       sigma
%   3) xtSpots structure array describing the extra spots (Gaussians), with fields
%       cx
%       cy
%       amp
%       % sigma  - NOT VARIED. USING CONSTANT SIZE DEFINED IN "PARAMS".
%
% In other words, the parameters vector for a multigaussian fit with two extra spots is:
% params = [offset, mainSpot.cx, .cy, .amp, .sigma, extraSpot(1).cx,
%       .cy, .amp, extraSpot(2).cx, .cy, .amp]

standardSize=params.fit_standardSize;
L=(size(plaquette,1)-1)/2;

% The initial values of parameters:
%   The initial offset estimate is supplied as input to multiGaussianFit
%   The main spot is centered at zero (the plaquette goes from -L to +L), has a standard
%       size, is not inclined and the amplitude is given by the center pixel - offset. 
%   The extra spots have initial locations provided as input to multiGaussianFit, all
%       have standard sizes and the amplitudes are given by pixel values at center
%       locations minus the offset.

if isempty(extraSpotsInfo)
    paramsExtra=[];
    lowerBoundsExtra=[];
    upperBoundsExtra=[];
else    
    paramsExtra=zeros(1,3*size(extraSpotsInfo,1));
    paramsExtra(1:3:end)= extraSpotsInfo(:,1); % x coordinates of centers
    paramsExtra(2:3:end)= extraSpotsInfo(:,2); % y coordinates of centers
    % Amplitudes
    paramsExtra(3:3:end)= 2*pi*standardSize^2*(extraSpotsInfo(:,3)-offset0); 
    
    % Now, set the bounds for the parameters. The extra spots should not be moved around
    % too much (+-2 pixels seems more than reasonable), the other bounds are not really
    % bounding but are simply to ensure no disasters happen.
    
    maxShift = params.fit_extraSpotShift;
    
    lowerBoundsExtra=zeros(1,3*size(extraSpotsInfo,1));
    lowerBoundsExtra(1:3:end)= extraSpotsInfo(:,1)-maxShift; % x coordinates of centers
    lowerBoundsExtra(2:3:end)= extraSpotsInfo(:,2)-maxShift; % y coordinates of centers
    % Amplitudes
    lowerBoundsExtra(3:3:end)= 0; 

    upperBoundsExtra=zeros(1,3*size(extraSpotsInfo,1));
    upperBoundsExtra(1:3:end)= extraSpotsInfo(:,1)+maxShift; % x coordinates of centers
    upperBoundsExtra(2:3:end)= extraSpotsInfo(:,2)+maxShift; % y coordinates of centers
    % Amplitudes
    upperBoundsExtra(3:3:end)= inf; 
end

cShift = params.fit_mainSpotShift;

params0 = [offset0, ...                                         % offset
    0, 0, 2*pi*standardSize^2*(plaquette(L+1,L+1)-offset0), ... % cx, cy, amp
    standardSize, ...                                           % sigma
    paramsExtra];                                               % extra spots
lowerBounds=[0, ...
    -cShift, -cShift, 0, ...
    0, ...
    lowerBoundsExtra];
upperBounds=[inf, ...
    cShift, cShift, inf, ...
    L, ...
    upperBoundsExtra];

lsqOptions=optimset('Display','none',...
    'maxfunevals',params.fit_maxfunevals,...
    'maxiter',params.fit_maxiter);

originalPixelVec=plaquette(:)';

[optparams, resid]=...
    lsqnonlin( @vecToMinimize, params0, lowerBounds, upperBounds, lsqOptions);

% If the fitting procedure set some parameters to the bounding values, that makes the
% fit suspicious. Store this information in infoFlag:
% bit 1: center X or center Y
% bit 2: r_x or r_y
% bit 3: some other parameter

% susp = short for "suspicious"
susp = (optparams == lowerBounds) | (optparams == upperBounds);
infoFlag = 1*uint16(susp(2)|susp(3))+...
           2*uint16(susp(5))+...
           4*uint16(sum(susp([1,4,6:end]))>0);
    
fparams=struct('off',single(optparams(1)),...
               'x_fit',single(optparams(2)),...
               'y_fit',single(optparams(3)),...
               'theta',-1,...
               'r_x',single(optparams(5)),...
               'r_y',single(optparams(5)),...
               'amp',single(optparams(4)),...
               'lsq',single(resid),...
               'x',uint16(0),...
               'y',uint16(0),...
               'z',uint16(0),...
               'shadowsDog',zeros(5,1,params.dataType),...
               'shadowsRaw',zeros(5,1,params.dataType),...
               'extraSpotsFitParams',single(optparams(6:end)),...
               'info',infoFlag);

    % Nested function - vector to minimize
           
    % Model the noise either
    %   * as gaussian with a fixed std. In this case the
    %   function to minimize is the sum of squares of deviations.
    %   So return the vector of deviations; 
    % OR
    %   * as gaussian with variance proportional to the mean. (This is a
    %   better approximation to Poisson noise). 
    %   In this case the function to minimize is the sum of squares of [deviations
    %   over standard deviations]. But we are still using lsqnonlin which
    %   minimizes the sum of squares of the components. So return the vector of
    %   deviations divided by standard deviation, i.e. square root of mean at this
    %   given location. 
    function vec = vecToMinimize(parameters)
        % The pixel vector generated using parameters (i.e. the fit to compare to
        % the original) 
        fitPixelVec = generateFit(L,standardSize,parameters(1),...
            parameters(2:5),parameters(6:end));
        if varNoiseStd
            vec = (originalPixelVec-fitPixelVec)./(fitPixelVec.^0.5);
        else
            vec =  originalPixelVec-fitPixelVec;
        end
    end
           
           
end

function fparams=multiGaussianFit_StandardCircle(plaquette, offset0, extraSpotsInfo,...
    varNoiseStd, params)
% Use non-linear least-square optimization
% We would like to minimize 
%   sum over pixels (original image - fit of the image)^2
% Therefore, we must pass to lsqnonlin the vector of pixel values differences.
% plaquette is the image we should fit to our multi-gaussian model. The "plaquette
%   coordinates are centered at (0,0); this is roughly where we assume the main point to
%   be. 
% offset0 is the initial estimate of the constant offset
% extraSpotsInfo is the K-by-3 matrix containing x and y coordinates of the neighboring
%   bright spots (in the plaquette coordinates) and their intensities on the raw image
%   (they are supplied to allow for the future possibility that the center of some of
%   the extra spots might actually be *outside* of the plaquette. This possibility is
%   not currently implemented). 

% The parameters for the fits have to form a vector. So although the different elements
% of this vector have completely different meanings, we'll have to lump them all
% together and parse it into separate meaningful values when necessary (see generateFit). 
% So, we will be using a vector "parameters" that should be interpreted as the
% values of the fields of the following two structures all written out in a sequence:
%   1) the value of the offset
%   2) mainSpot structure describing the main spot (circular Gaussian of a fixed size), 
%   with fields
%       cx
%       cy          center coordinates
%       amp         the amplitude
%       % sigma  - NOT VARIED. USING CONSTANT SIZE DEFINED IN "PARAMS".
%   3) xtSpots structure array describing the extra spots (Gaussians), with fields
%       cx
%       cy
%       amp
%       % sigma  - NOT VARIED. USING CONSTANT SIZE DEFINED IN "PARAMS".
%
% In other words, the parameters vector for a multigaussian fit with two extra spots is:
% params = [offset, mainSpot.cx, .cy, .amp, extraSpot(1).cx,
%       .cy, .amp, extraSpot(2).cx, .cy, .amp]

standardSize=params.fit_standardSize;
L=(size(plaquette,1)-1)/2;

% The initial values of parameters:
%   The initial offset estimate is supplied as input to multiGaussianFit
%   The main spot is centered at zero (the plaquette goes from -L to +L), has a standard
%       size, is not inclined and the amplitude is given by the center pixel - offset. 
%   The extra spots have initial locations provided as input to multiGaussianFit, all
%       have standard sizes and the amplitudes are given by pixel values at center
%       locations minus the offset.

if isempty(extraSpotsInfo)
    paramsExtra=[];
    lowerBoundsExtra=[];
    upperBoundsExtra=[];
else    
    paramsExtra=zeros(1,3*size(extraSpotsInfo,1));
    paramsExtra(1:3:end)= extraSpotsInfo(:,1); % x coordinates of centers
    paramsExtra(2:3:end)= extraSpotsInfo(:,2); % y coordinates of centers
    % Amplitudes
    paramsExtra(3:3:end)= 2*pi*standardSize^2*(extraSpotsInfo(:,3)-offset0); 
    
    % Now, set the bounds for the parameters. The extra spots should not be moved around
    % too much (+-2 pixels seems more than reasonable), the other bounds are not really
    % bounding but are simply to ensure no disasters happen.
    
    maxShift = params.fit_extraSpotShift;
    
    lowerBoundsExtra=zeros(1,3*size(extraSpotsInfo,1));
    lowerBoundsExtra(1:3:end)= extraSpotsInfo(:,1)-maxShift; % x coordinates of centers
    lowerBoundsExtra(2:3:end)= extraSpotsInfo(:,2)-maxShift; % y coordinates of centers
    % Amplitudes
    lowerBoundsExtra(3:3:end)= 0; 

    upperBoundsExtra=zeros(1,3*size(extraSpotsInfo,1));
    upperBoundsExtra(1:3:end)= extraSpotsInfo(:,1)+maxShift; % x coordinates of centers
    upperBoundsExtra(2:3:end)= extraSpotsInfo(:,2)+maxShift; % y coordinates of centers
    % Amplitudes
    upperBoundsExtra(3:3:end)= inf; 
end

cShift = params.fit_mainSpotShift;

params0 = [offset0, ...                                         % offset
    0, 0, 2*pi*standardSize^2*(plaquette(L+1,L+1)-offset0), ... % cx, cy, amp
    paramsExtra];                                               % extra spots
lowerBounds=[0, ...
    -cShift, -cShift, 0, ...
    lowerBoundsExtra];
upperBounds=[inf, ...
    cShift, cShift, inf, ...
    upperBoundsExtra];

lsqOptions=optimset('Display','none',...
    'maxfunevals',params.fit_maxfunevals,...
    'maxiter',params.fit_maxiter);

originalPixelVec=plaquette(:)';

[optparams, resid]=...
    lsqnonlin( @vecToMinimize, params0, lowerBounds, upperBounds, lsqOptions);

% If the fitting procedure set some parameters to the bounding values, that makes the
% fit suspicious. Store this information in infoFlag:
% bit 1: center X or center Y
% bit 2: r_x or r_y
% bit 3: some other parameter

% susp = short for "suspicious"
susp = (optparams == lowerBounds) | (optparams == upperBounds);
infoFlag = 1*uint16(susp(2)|susp(3))+...
           4*uint16(sum(susp([1,4,5:end]))>0);
    
fparams=struct('off',single(optparams(1)),...
               'x_fit',single(optparams(2)),...
               'y_fit',single(optparams(3)),...
               'theta',-1,...
               'r_x',standardSize,...
               'r_y',standardSize,...
               'amp',single(optparams(4)),...
               'lsq',single(resid),...
               'x',uint16(0),...
               'y',uint16(0),...
               'z',uint16(0),...
               'shadowsDog',zeros(5,1,params.dataType),...
               'shadowsRaw',zeros(5,1,params.dataType),...
               'extraSpotsFitParams',single(optparams(5:end)),...
               'info',infoFlag);

    % Nested function - vector to minimize
           
    % Model the noise either
    %   * as gaussian with a fixed std. In this case the
    %   function to minimize is the sum of squares of deviations.
    %   So return the vector of deviations; 
    % OR
    %   * as gaussian with variance proportional to the mean. (This is a
    %   better approximation to Poisson noise). 
    %   In this case the function to minimize is the sum of squares of [deviations
    %   over standard deviations]. But we are still using lsqnonlin which
    %   minimizes the sum of squares of the components. So return the vector of
    %   deviations divided by standard deviation, i.e. square root of mean at this
    %   given location. 
    function vec = vecToMinimize(parameters)
        % The pixel vector generated using parameters (i.e. the fit to compare to
        % the original) 
        fitPixelVec = generateFit(L,standardSize,parameters(1),parameters(2:end));
        if varNoiseStd
            vec = (originalPixelVec-fitPixelVec)./(fitPixelVec.^0.5);
        else
            vec =  originalPixelVec-fitPixelVec;
        end
    end
           
           
end

% function filters = generateSectorFilters(aRmin, aRmax)
%     discRmax = fspecial('disk',aRmax);
%     discRmin = padarray(fspecial('disk',aRmin),[aRmax-aRmin,aRmax-aRmin]);
%     annulus = discRmax/max(discRmax(:))-discRmax/max(discRmin(:));
%     filters = zeros([size(annulus),8]); % a collection of 8 filters
%     [X,Y] = meshgrid(-aRmax:aRmax);
%     XmY = X-Y;
%     XpY = X+Y;
%     N=XmY>0 & XpY < 0;
%     E=XmY>0 & XpY > 0;
%     S=XmY<0 & XpY > 0;
%     W=XmY<0 & XpY < 0;
%     NE = X>0 & Y<0;
%     SE = X>0 & Y>0;
%     SW = X<0 & Y>0;
%     NW = X<0 & Y<0;
%     filters(:,:,1)=annulus.*N >0.5;
%     filters(:,:,2)=annulus.*NE>0.5; 
%     filters(:,:,3)=annulus.*E >0.5; 
%     filters(:,:,4)=annulus.*SE>0.5; 
%     filters(:,:,5)=annulus.*S >0.5; 
%     filters(:,:,6)=annulus.*SW>0.5;
%     filters(:,:,7)=annulus.*W >0.5; 
%     filters(:,:,8)=annulus.*NW>0.5;     
% end